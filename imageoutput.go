package oiio

/*
#include "stdlib.h"

#include "cpp/oiio.h"

*/
import "C"

import (
	"errors"
	"runtime"
	"unsafe"
)

// ImageOutput abstracts the writing of an image file in a file format-agnostic manner.
type ImageOutput struct {
	ptr unsafe.Pointer
}

func newImageOutput(i unsafe.Pointer) *ImageOutput {
	in := &ImageOutput{i}
	runtime.SetFinalizer(in, deleteImageOutput)
	return in
}

func deleteImageOutput(i *ImageOutput) {
	if i.ptr != nil {
		C.deleteImageOutput(i.ptr)
		i.ptr = nil
	}
	runtime.KeepAlive(i)
}

// Create an ImageOutput that will write to a file, with the format
// inferred from the extension of the name. This just creates the ImageOutput, it
// does not open the file.
func OpenImageOutput(filename string) (*ImageOutput, error) {
	c_str := C.CString(filename)

	// TODO: Provide optional argument for plugin path
	c_path := C.CString("")

	defer C.free(unsafe.Pointer(c_str))
	defer C.free(unsafe.Pointer(c_path))

	ptr := C.ImageOutput_Create(c_str, c_path)

	out := newImageOutput(ptr)

	return out, out.LastError()
}

// Destroy the object immediately instead of waiting for GC.
func (i *ImageOutput) Destroy() {
	runtime.SetFinalizer(i, nil)
	deleteImageOutput(i)
}

// Return the last error generated by API calls.
// An nil error will be returned if no error has occured.
func (i *ImageOutput) LastError() error {
	c_str := C.ImageOutput_geterror(i.ptr)
	runtime.KeepAlive(i)
	if c_str == nil {
		return nil
	}
	err := C.GoString(c_str)
	if err == "" {
		return nil
	}
	return errors.New(err)
}

// Given the name of a 'feature', return whether this ImageOutput
// supports output of images with the given properties.
// Feature names that ImageIO plugins are expected to recognize
// include:
//    "tiles"          Is this format able to write tiled images?
//    "rectangles"     Does this plugin accept arbitrary rectangular
//                       pixel regions, not necessarily aligned to
//                       scanlines or tiles?
//    "random_access"  May tiles or scanlines be written in
//                       any order (false indicates that they MUST
//                       be in successive order).
//    "multiimage"     Does this format support multiple subimages
//                       within a file?
//    "appendsubimage" Does this format support adding subimages one at
//                       a time through open(name,spec,AppendSubimage)?
//                       If not, then open(name,subimages,specs) must
//                       be used instead.
//    "mipmap"         Does this format support multiple resolutions
//                       for an image/subimage?
//    "volumes"        Does this format support "3D" pixel arrays?
//    "rewrite"        May the same scanline or tile be sent more than
//                       once?  (Generally, this will be true for
//                       plugins that implement interactive display.)
//    "empty"          Does this plugin support passing a NULL data
//                       pointer to write_scanline or write_tile to
//                       indicate that the entire data block is zero?
//    "channelformats" Does the plugin/format support per-channel
//                       data formats?
//    "displaywindow"  Does the format support display ("full") windows
//                        distinct from the pixel data window?
//    "origin"         Does the format support a nonzero x,y,z
//                        origin of the pixel data window?
//    "negativeorigin" Does the format support negative x,y,z
//                        and full_{x,y,z} origin values?
//    "deepdata"       Deep (multi-sample per pixel) data
//
// Note that main advantage of this approach, versus having
// separate individual supports_foo() methods, is that this allows
// future expansion of the set of possible queries without changing
// the API, adding new entry points, or breaking linkage
// compatibility.
func (i *ImageOutput) Supports(feature string) bool {
	c_str := C.CString(feature)
	defer C.free(unsafe.Pointer(c_str))
	ret := bool(C.ImageOutput_supports(i.ptr, c_str))
	runtime.KeepAlive(i)
	return ret
}

// Return a reference to the image format specification of the current subimage/MIPlevel.
// Note that the contents of the spec will be empty unless it is further added to it
func (i *ImageOutput) Spec() *ImageSpec {
	ptr := C.ImageOutput_spec(i.ptr)
	runtime.KeepAlive(i)
	return &ImageSpec{ptr}
}

// Return the name of the format implemented by this image.
func (i *ImageOutput) FormatName() string {
	ret := C.GoString(C.ImageOutput_format_name(i.ptr))
	runtime.KeepAlive(i)
	return ret
}
